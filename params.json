{"name":"JUnit Xml Reports toolkit","tagline":"A command line tool for helping manage JUnit XML formatted reports.","body":"# JUnit XML Reporting Toolkit\r\n\r\nA command line tool for helping manage JUnit XML formatted reports.\r\n\r\n## Installation\r\n\r\nTo get the toolkit locally just use [Cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html):\r\n\r\n```\r\ncargo install juxr\r\n```              \r\n\r\n*NOTE:* Unsigned binaries built by GitHub Actions are provided for convenience and are available in [Releases](https://github.com/cloudbees-oss/juxr/releases).\r\nThe recommended installation path is to build from source using `cargo install juxr`.\r\n\r\n## Extract reports over Standard I/O\r\n\r\n> As a developer, I have some tests running in a temporary Kubernetes pod and I need to exract the test results and any associated [attachments](https://plugins.jenkins.io/junit-attachments/)\r\n\r\nThe toolkit provides three sub-commands to assist with this.\r\n\r\nFirstly there is the `export` subcommand. You run this command in your pod and it will pipe the reports (and any attachments) to standard out.\r\n\r\nThen there is the `import` subcommand. You run this command on the receiving end and pipe the Kubernetes logs through it.\r\n\r\nFinally, there is a specialized variant of `export` in the `exec` subcommand. You run this again in your pod mut use it to wrap the test launch command.\r\n\r\nYou will want to include the toolkit in your test image, e.g.:\r\n\r\nIf you are using the `export` you will change your entry point to run something like `juxr export -r  **/TEST-*.xml` or whatever the test report pattern you need.\r\n\r\nAs you will likely want to have the pod terminate with a success/failure exit code, a simpler option is to just change the command that runs your tests from `some_command arg arg` to `juxr exec -r **/TEST-*.xml -- some_command arg arg` as this will take care of launching the command and propagating the error code after exporting the test reports.\r\n\r\nHave a look at the `juxr help export` and `juxr help exec` for details of the other export options such as secret redaction and renaming of tests / suites.\r\n\r\nIf you do not want to use the `juxr` toolkit inside your test container you can achieve the same result with base64 encoding, however this will not provide for \r\n\r\n```bash\r\nneedle=\"[[juxr::stream::$RANDOM::junit-test-report::TEST-custom.xml]]\"\r\n# NOTE: there must be a new line before the needle\r\necho \"\" \r\necho $needle\r\nbase64 < TEST-custom.xml\r\necho $needle\r\n```         \r\n\r\nThen on the receiving end you just pipe the logs through `juxr import`, e.g. if using `helm test` to run your test container:\r\n\r\n```\r\nhelm test --logs | juxr import -o helm-test-results/\r\n```                                   \r\n\r\nThe import command will output all non-needle bookended content to standard out and write the files to the specified output directory\r\n\r\n## Convert TAP formatted reports to JUnit XML format\r\n\r\n> As a developer I have a testing tool that outputs TAP formatted test reports but I need to consume JUnit XML formatted reports\r\n\r\nThe `tap` subcommand will convert TAP version 12 or 13 output into JUnit XML format.\r\n\r\nYou can either pipe the output through or have the test command run by the toolkit, e.g.\r\n\r\n```\r\nsome_command arg arg | juxr tap --name \"some_command.tests\" -o test-results/\r\n```                                       \r\n\r\nor \r\n```\r\njuxr tap --name \"some_command.tests\" -o test-results/ -- some_command arg arg\r\n```     \r\n\r\nThe later form will attempt to infer test durations and will propagate the exit code                                  \r\n\r\n## Generate a JUnit XML report from executing a single command\r\n\r\n> As a developer I have a single command which I would like to turn into a JUnit XML report\r\n\r\nThe `test` sub command will run a single command and produce a JUnit XML report that includes the commands output, e.g.\r\n\r\n```\r\njuxr test --name \"some.command\" --test \"arg1 arg2\" -o test-results/ -- some_command arg1 arg2\r\n```            \r\n\r\nThis will produce a `TEST-some.command.xml` file in `test-results`.\r\n\r\nLook at `juxr help test` for details on how to control the exit code mapping to differentiate the test status.\r\n\r\n## Generate a JUnit XML report from running a suite of simple command\r\n\r\n> As a developer, I have a series of different commands which represent independent tests I would like to run and record.\r\n\r\nFor this use case we recommend that you use something like the excellent [bats](https://github.com/bats-core/bats-core) test framework.\r\nYou can generate JUnit XML Foratted reports with this framework and you have control over the sequencing of tests.\r\n\r\nHowever, sometimes you just need something quick and dirty... enter the `run` subcommand.\r\n\r\nThis takes a flexible YAML formatted description of a suite of tests and runs them in alphabetical order.\r\nAn example suite of tests could look like:\r\n\r\n```yaml\r\n\"001 echo greeting using the current shell\": >\r\n  if [[ $(($(($RANDOM%10))%2)) -eq 1 ]] ;\r\n  then\r\n    echo hello world ;\r\n  else\r\n    echo hi world ;\r\n  fi\r\n\"002 echo a greeting using the echo binary\":\r\n  - echo\r\n  - \"hello world\"\r\n\"003 the false command when executed by the current shell should exit with non-zero\":\r\n  cmd: \"false\" # need to quote values that YAML might perform type conversions on\r\n  success: 1\r\n  failure: 0\r\n\"004 skip this test\":\r\n  cmd:\r\n    - \"false\"\r\n  skipped: 1\r\n  failure: 2 # need to move it off it's default of 1\r\n\"005 exit code 1 or 2 is success 3 or 4 means skip and 5 or 6 is failure otherwise an error\":\r\n  cmd:\r\n    - sh\r\n    - \"-c\"\r\n    - \"exit 2\"\r\n  success:\r\n    - 1\r\n    - 2\r\n  skipped:\r\n    - 3\r\n    - 4\r\n  failure:\r\n    - 5\r\n    - 6\r\n```                             \r\n\r\nThe top level keys are the test names.\r\n\r\n* If the value of the key is a string then it will be executed using `sh -c` (or `cmd /C` on Windows)\r\n* If the value of the key is an array of strings then the first value will be used as the program name and the remaining values will be passed as the program arguments\r\n* If the value of the key is an object then the command will be taken from the `cmd` or `command` key in the object (which takes a string or an array of strings).\r\n* The object form also permits specifying the expected exit codes for different test statuses\r\n\r\n  * `success` takes either a single value or an array of values indicating the exit code of the program to interpret as a successful test result. If not specified then it is assumed to have the value `0`. \r\n  * `failure` takes either a single value or an array of values indicating the exit code of the program to interpret as a failed test result. If not specified then it is assumed to have the value `1`. \r\n  * `skipped` takes either a single value or an array of values indicating the exit code of the program to interpret as a successful test result. If not specified then the test will never be skipped.\r\n  \r\n  Note: if you want to use exit code `1` or `0` for anything other than `failure` or `success` respectively then you will need to override the defaults\r\n  \r\n  Note: an exit code other than those defined for `success`, `failure` or `skipped` will mark the test result as an error. \r\n\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}